# SQL

## Jaywalkingアンチパターン（カンマ区切りIDリスト）

| 項目 | 値 |
|------|----|
| 理解度 | ▪︎◻︎◻︎◻︎ |
| 保存日 | 2026-02-23 |
| 最終復習 | 2026-02-23 |
| 次回復習 | 2026-02-24 |

**Q:** カラムにIDをカンマ区切りで格納すると何が問題か？

**A:** 正規のJOIN（`ON A.id = B.id`）が使えず、`LIKE '%id%'` や `REGEXP '\bid\b'` での文字列検索に頼るしかない。インデックスは値の先頭で索引するため、`%id%` のような中間一致に対応できず全件スキャンになる。`LIKE '%5%'` は15や52にも誤マッチするため `REGEXP '\b5\b'` で回避できるが、インデックス非使用という根本問題は解決しない。

**メモ:** INNER JOINは概念的に「クロス積（全組み合わせ）→ 条件でフィルタ」だが、実際はインデックスを使ってピンポイント取得にショートカットする。カンマ区切りリストはそのショートカットもJOINの恩恵も両方失う。解決策は中間テーブルによる正規化。（出典: SQLアンチパターン 2章）

## upsert によるトグル設計（ポイント加減算）

| 項目 | 値 |
|------|----|
| 理解度 | ▪︎◻︎◻︎◻︎ |
| 保存日 | 2026-02-23 |
| 最終復習 | 2026-02-23 |
| 次回復習 | 2026-02-24 |

**Q:** タスク完了/未完了のトグルでポイントを正確に加減算したい場合、update・insert・upsert をどう使い分けるか？

**A:** upsert（INSERT + ON CONFLICT DO UPDATE）を使う。初回のみINSERT、2回目以降はUPDATE でフラグを上書きするため、テーブルには常に1行だけ存在する。フロントから新しい状態（true/false）を受け取り、トランザクション内で upsert + ポイント更新を行う。UPDATE 単体だと「レコードなし時に何も起きない」「押すたびにポイント加算されてしまう」問題があり不適切。

**メモ:** フロントが現在の状態を知っているため、DB への SELECT は不要。`completed=true なら+10、false なら-10` と受け取った値で分岐するだけでよい。upsert + トランザクションで1回の接続で完結する。
