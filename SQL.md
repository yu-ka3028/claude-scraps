# SQL

## Jaywalkingアンチパターン（カンマ区切りIDリスト）

| 項目 | 値 |
|------|----|
| 理解度 | ▪︎▪︎◻︎◻︎ |
| 保存日 | 2026-02-23 |
| 最終復習 | 2026-02-25 |
| 次回復習 | 2026-02-28 |

**Q:** カラムにIDをカンマ区切りで格納すると何が問題か？

**A:** 正規のJOIN（`ON A.id = B.id`）が使えず、`LIKE '%id%'` や `REGEXP '\bid\b'` での文字列検索に頼るしかない。インデックスは値の先頭で索引するため、`%id%` のような中間一致に対応できず全件スキャンになる。`LIKE '%5%'` は15や52にも誤マッチするため `REGEXP '\b5\b'` で回避できるが、インデックス非使用という根本問題は解決しない。

**メモ:** INNER JOINは概念的に「クロス積（全組み合わせ）→ 条件でフィルタ」だが、実際はインデックスを使ってピンポイント取得にショートカットする。カンマ区切りリストはそのショートカットもJOINの恩恵も両方失う。解決策は中間テーブルによる正規化。（出典: SQLアンチパターン 2章）

## カンマ区切り FROM と JOIN の等価性

| 項目 | 値 |
|------|----|
| 理解度 | ▪︎◻︎◻︎◻︎ |
| 保存日 | 2026-02-25 |
| 最終復習 | 2026-02-25 |
| 次回復習 | 2026-02-28 |

**Q:** `FROM A, B` と `FROM A, B WHERE A.id = B.id` はそれぞれ何と同義か？

**A:** `FROM A, B` は `CROSS JOIN`（直積）と同義。`WHERE` で絞り込むと結果は `INNER JOIN` と同じになるが、構文としては「CROSS JOIN → WHERE フィルタ」という処理。カンマ自体は INNER JOIN ではなく CROSS JOIN。

**メモ:** `FROM A, B WHERE ...` は「旧式の INNER JOIN 記法」と説明されることがあるが、それは結果が同じというだけ。構文的には CROSS JOIN + フィルタ。明示的な `INNER JOIN ... ON` の方が意図が伝わりやすく現代では推奨される。

## CTE（Common Table Expression）

| 項目 | 値 |
|------|----|
| 理解度 | ▪︎▪︎◻︎◻︎ |
| 保存日 | 2026-02-25 |
| 最終復習 | 2026-02-27 |
| 次回復習 | 2026-03-02 |

**Q:** CTEとは何か？名前のないサブクエリとの違いは？

**A:** `WITH 名前 AS (サブクエリ)` の形で書く**名前付き**サブクエリ。CTEは必ず名前を持ち、そのクエリ内でのみ有効なスコープを持ち、後続の `SELECT` から複数回参照できる。名前のないインラインのサブクエリは「派生テーブル」「インラインビュー」と呼ばれ、CTEとは区別される。

**メモ:** "Common Table Expression" の "Table Expression" が「名前を付けてテーブルのように扱える」という意味を含む。使うときは「CTEを定義/宣言する」が自然な表現（「設定する」より）。複雑なサブクエリを上から順に分解して可読性を上げるのが主な用途。

## ウィンドウ関数とページネーション最適化

| 項目 | 値 |
|------|----|
| 理解度 | ▪︎◻︎◻︎◻︎ |
| 保存日 | 2026-02-25 |
| 最終復習 | 2026-02-25 |
| 次回復習 | 2026-02-26 |

**Q:** ページネーションで「総件数 + 現ページデータ」を1クエリで返すとき、CTE方式とウィンドウ関数方式でどう違うか？

**A:** CTE方式は `aTable` を2回スキャンする。

```sql
-- CTE方式（非効率）
WITH total_count AS (
  SELECT COUNT(*) FROM aTable WHERE ...  -- 1回目
)
SELECT a, b, t.total_count
FROM aTable, total_count t               -- 2回目 + クロス結合
WHERE ...
```

ウィンドウ関数は1回のスキャンで完結する。

```sql
-- ウィンドウ関数方式
SELECT a, b,
  COUNT(*) OVER () AS total_count  -- LIMIT前の全件数を各行に付ける
FROM aTable t
WHERE ...
LIMIT x OFFSET y
```

**メモ:** ウィンドウ関数は「集計しながら元の行を消さない」のが特徴。`GROUP BY` はグループを1行に畳むが、`OVER()` は各行を残したまま集計値を付けられる。`COUNT(*) OVER()` は `PARTITION BY` なしだと WHERE 絞り込み後・LIMIT 適用前の全件数が対象になる。

## COUNT(*) OVER() と PARTITION BY の挙動

| 項目 | 値 |
|------|----|
| 理解度 | ▪︎◻︎◻︎◻︎ |
| 保存日 | 2026-02-25 |
| 最終復習 | 2026-02-25 |
| 次回復習 | 2026-02-26 |

**Q:** `COUNT(*) OVER()` と `MAX(total_count)` が同義になるのはなぜ？また PARTITION BY があると何が変わる？

**A:**
- `COUNT(*) OVER()`（PARTITION BYなし）は全行に**同じ値**（全体行数）を貼り付けるため、MAX しても値は変わらず同義になる
- `PARTITION BY category` を指定すると、各行に「自分が属するパーティション内の行数」が貼り付けられる（行によって値が異なる）
- そのため PARTITION BY ありの場合、`MAX` すると「最大パーティションのカウント」になり全体行数とは別物になる

---

## MAX を「値を取り出す」目的で使うパターン（GROUP BY 制約）

| 項目 | 値 |
|------|----|
| 理解度 | ▪︎◻︎◻︎◻︎ |
| 保存日 | 2026-02-25 |
| 最終復習 | 2026-02-25 |
| 次回復習 | 2026-02-26 |

**Q:** GROUP BY のある外側クエリでウィンドウ関数の結果を参照したいとき、なぜ `MAX` を使うのか？`COUNT` ではダメなのか？

**A:**
- GROUP BY は複数行を1行に潰す。潰された列は「どの値を使うか決められない」ため集約関数で1つの値に決める必要がある
- `COUNT(*) OVER()` の結果（`total_count`）は全行同じ値なので、`MAX` で包んで取り出しても値は変わらない（MIN/ANY_VALUE でも同じ）
- `COUNT(total_count)` は「NULLでない行数」を数えてしまい、値を取り出す目的に合わない
- `ANY_VALUE` が最も意図明確だが、慣習的に `MAX` が使われることが多い

**メモ:**
```
id | category | price
 1 | A        | 100
 2 | A        | 200   ← A グループに price が2つある
 3 | B        | 300
```
```sql
SELECT category, price      -- ❌ price はどっち？
FROM orders GROUP BY category

SELECT category, MAX(price) -- ✅ 最大値に決める
SELECT category, SUM(price) -- ✅ 合計に決める
SELECT category, COUNT(*)   -- ✅ 件数に決める
```

---

## upsert によるトグル設計（ポイント加減算）

| 項目 | 値 |
|------|----|
| 理解度 | ▪︎▪︎◻︎◻︎ |
| 保存日 | 2026-02-23 |
| 最終復習 | 2026-02-25 |
| 次回復習 | 2026-02-28 |

**Q:** タスク完了/未完了のトグルでポイントを正確に加減算したい場合、update・insert・upsert をどう使い分けるか？

**A:** upsert（INSERT + ON CONFLICT DO UPDATE）を使う。初回のみINSERT、2回目以降はUPDATE でフラグを上書きするため、テーブルには常に1行だけ存在する。フロントから新しい状態（true/false）を受け取り、トランザクション内で upsert + ポイント更新を行う。UPDATE 単体だと「レコードなし時に何も起きない」「押すたびにポイント加算されてしまう」問題があり不適切。

**メモ:** フロントが現在の状態を知っているため、DB への SELECT は不要。`completed=true なら+10、false なら-10` と受け取った値で分岐するだけでよい。upsert + トランザクションで1回の接続で完結する。
